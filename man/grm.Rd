% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/compute_grm.R
\name{grm}
\alias{grm}
\title{Computing the genomic relationship matrix (GRM)}
\usage{
grm(Glist = NULL, GRMlist = NULL, ids = NULL, rsids = NULL,
  rws = NULL, cls = NULL, W = NULL, method = "add",
  scaled = TRUE, msize = 100, ncores = 1, fnG = NULL,
  overwrite = FALSE, returnGRM = FALSE, miss = 0, task = "grm")
}
\arguments{
\item{Glist}{a list providing information about genotypes stored on disk}

\item{ids}{a vector of individual ids used for computing GRM}

\item{rsids}{a vector genotype marker rsids used for computing GRM}

\item{rws}{rows in genotype matrix used for computing GRM}

\item{cls}{columns in genotype matrix used for computing GRM}

\item{W}{matrix of centered and scaled genotypes}

\item{method}{indicator of method used for computing GRM; additive (add, default), dominance (dom) or epistasis (epi-pairs or epi-hadamard (all genotype markers))}

\item{msize}{number of genotype markers used for batch processing}

\item{ncores}{number of cores used to compute the GRM}

\item{fnG}{name of the binary file used for storing the GRM on disk}

\item{overwrite}{logical if TRUE the binary file fnG will be overwritten}

\item{returnGRM}{logical if TRUE function returns the GRM matrix to the R environment}

\item{miss}{is the missing code (miss=0 is default) used for missing values in the genotype data}

\item{task}{computation (task="grm" is default) or eigen value decompostion (task="eigen")}
}
\value{
Returns a genomic relationship matrix (GRM) if returnGRM=TRUE else a list structure (GRMlist) with information about the GRM  stored on disk
}
\description{
The grm function is used to compute a genomic relationship matrix (GRM) based on all, 
or a subset of marker genotypes. The output of the grm function can either be a 
within-memory GRM object (n x n matrix), or a GRM-list which is a list structure that 
contains information about the GRM stored in a binary file on the disk.
}
\examples{

# Simulate data
W <- matrix(rnorm(20000000), ncol = 10000)
	colnames(W) <- as.character(1:ncol(W))
	rownames(W) <- as.character(1:nrow(W))

# Compute GRM
GRM <- grm(W = W)

# Eigen value decompostion GRM
eig <- grm(GRM=GRM, task="eigen")
}
\author{
Peter Soerensen
}
